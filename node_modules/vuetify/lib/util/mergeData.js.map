{"version":3,"sources":["../../src/util/mergeData.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @copyright 2017 Alex Regan\n * @license MIT\n * @see https://github.com/alexsasharegan/vue-functional-data-merge\n */\n\nimport { VNodeData } from 'vue'\n\n/**\n * Intelligently merges data for createElement.\n * Merges arguments left to right, preferring the right argument.\n * Returns new VNodeData object.\n */\nexport default function mergeData (...vNodeData: VNodeData[]): VNodeData\nexport default function mergeData (): VNodeData {\n  const mergeTarget: VNodeData & { [key: string]: any } = {}\n  let i: number = arguments.length\n  let prop: string\n  let event: string\n\n  // Allow for variadic argument length.\n  while (i--) {\n    // Iterate through the data properties and execute merge strategies\n    // Object.keys eliminates need for hasOwnProperty call\n    for (prop of Object.keys(arguments[i])) {\n      switch (prop) {\n        // Array merge strategy (array concatenation)\n        case 'class':\n        case 'style':\n        case 'directives':\n          if (!Array.isArray(mergeTarget[prop])) {\n            mergeTarget[prop] = []\n          }\n          // Repackaging in an array allows Vue runtime\n          // to merge class/style bindings regardless of type.\n          mergeTarget[prop] = mergeTarget[prop].concat(arguments[i][prop])\n          break\n        // Space delimited string concatenation strategy\n        case 'staticClass':\n          if (!arguments[i][prop]) {\n            break\n          }\n          if (mergeTarget[prop] === undefined) {\n            mergeTarget[prop] = ''\n          }\n          if (mergeTarget[prop]) {\n            // Not an empty string, so concatenate\n            mergeTarget[prop] += ' '\n          }\n          mergeTarget[prop] += arguments[i][prop].trim()\n          break\n        // Object, the properties of which to merge via array merge strategy (array concatenation).\n        // Callback merge strategy merges callbacks to the beginning of the array,\n        // so that the last defined callback will be invoked first.\n        // This is done since to mimic how Object.assign merging\n        // uses the last given value to assign.\n        case 'on':\n        case 'nativeOn':\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {}\n          }\n          const listeners = mergeTarget[prop]!\n          for (event of Object.keys(arguments[i][prop] || {})) {\n            // Concat function to array of functions if callback present.\n            if (listeners[event]) {\n              // Insert current iteration data in beginning of merged array.\n              listeners[event] = Array<Function>().concat( // eslint-disable-line\n                listeners[event],\n                arguments[i][prop][event]\n              )\n            } else {\n              // Straight assign.\n              listeners[event] = arguments[i][prop][event]\n            }\n          }\n          break\n        // Object merge strategy\n        case 'attrs':\n        case 'props':\n        case 'domProps':\n        case 'scopedSlots':\n        case 'staticStyle':\n        case 'hook':\n        case 'transition':\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {}\n          }\n          mergeTarget[prop] = { ...arguments[i][prop], ...mergeTarget[prop] }\n          break\n        // Reassignment strategy (no merge)\n        case 'slot':\n        case 'key':\n        case 'ref':\n        case 'tag':\n        case 'show':\n        case 'keepAlive':\n        default:\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = arguments[i][prop]\n          }\n      }\n    }\n  }\n\n  return mergeTarget\n}\n"],"sourceRoot":"","file":"mergeData.js"}